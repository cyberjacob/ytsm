import mimetypes

import re

import os
from string import Template
from typing import Optional, Union
import logging

import requests

from YtManagerApp.models import Video, Subscription
from external.pytaw.pytaw.youtube import Thumbnail, Resource, Channel, Playlist

import youtube_dl
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from django.db.models.fields.files import ImageFieldFile


def build_youtube_dl_params(video: Video):
    sub = video.subscription
    user = sub.user

    # resolve path
    download_path = user.preferences['download_path']

    template_dict = build_template_dict(video)
    output_pattern = Template(user.preferences['download_file_pattern']).safe_substitute(template_dict)

    output_path = os.path.join(download_path, output_pattern)
    output_path = os.path.normpath(output_path)

    youtube_dl_params = {
        'logger': logging.getLogger(youtube_dl.__name__),
        'format': user.preferences['download_format'],
        'outtmpl': output_path,
        'writethumbnail': False,
        'writedescription': False,
        'writesubtitles': user.preferences['download_subtitles'],
        'writeautomaticsub': user.preferences['download_autogenerated_subtitles'],
        'allsubtitles': user.preferences['download_subtitles_all'],
        'merge_output_format': 'mp4',
        'postprocessors': [
            {
                'key': 'FFmpegMetadata'
            },
        ]
    }

    sub_langs = user.preferences['download_subtitles_langs'].split(',')
    sub_langs = [i.strip() for i in sub_langs]
    if len(sub_langs) > 0:
        youtube_dl_params['subtitleslangs'] = sub_langs

    sub_format = user.preferences['download_subtitles_format']
    if len(sub_format) > 0:
        youtube_dl_params['subtitlesformat'] = sub_format

    return youtube_dl_params, output_path


def build_template_dict(video: Video):
    return {
        'channel': video.subscription.channel_name,
        'channel_id': video.subscription.channel_id,
        'playlist': video.subscription.name,
        'playlist_id': video.subscription.playlist_id,
        'playlist_index': "{:03d}".format(1 + video.playlist_index),
        'title': video.name,
        'id': video.video_id,
    }


def get_valid_path(path):
    """
    Normalizes string, converts to lowercase, removes non-alpha characters,
    and converts spaces to hyphens.
    """
    import unicodedata
    value = unicodedata.normalize('NFKD', path).encode('ascii', 'ignore').decode('ascii')
    value = re.sub('[:"*]', '', value).strip()
    value = re.sub('[?<>|]', '#', value)
    return value


def best_thumbnail(resource: Resource) -> Optional[Thumbnail]:
    """
    Gets the best thumbnail available for a resource.
    :param resource:
    :return:
    """
    thumbs = getattr(resource, 'thumbnails', None)

    if thumbs is None or len(thumbs) <= 0:
        return None

    return max(thumbs, key=lambda t: t.width * t.height)


def fill_from_playlist(subscription: Subscription, info_playlist: Playlist, log):
    subscription.name = info_playlist.title
    subscription.playlist_id = info_playlist.id
    subscription.description = info_playlist.description
    subscription.channel_id = info_playlist.channel_id
    subscription.channel_name = info_playlist.channel_title

    load_thumbnail(info_playlist.id, info_playlist, subscription.thumb, log)

    subscription.save()


def copy_from_channel(subscription: Subscription, info_channel: Channel, log):
    # No point in storing info about the 'uploads from X' playlist
    subscription.name = info_channel.title
    subscription.playlist_id = info_channel.uploads_playlist.id
    subscription.description = info_channel.description
    subscription.channel_id = info_channel.id
    subscription.channel_name = info_channel.title
    subscription.rewrite_playlist_indices = True

    load_thumbnail(info_channel.id, info_channel, subscription.thumb, log)

    subscription.save()


def load_thumbnail(item_id: str, url: Union[Resource, str], field: ImageFieldFile, log: logging.Logger):
    if url is Resource:
        url = best_thumbnail(url).url
    try:
        response = requests.get(url, stream=True)
        ext = mimetypes.guess_extension(response.headers['Content-Type'])
        file_name = f"{item_id}{ext}"

        field.save(file_name, response.content)
    except requests.exceptions.RequestException as e:
        log.error('Error while downloading stream for thumbnail %s. Error: %s', url, e)
